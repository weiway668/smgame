# 小梦想游戏 - 技术方案

## 1. 技术架构

### 1.1 整体架构
```
┌─────────────────────────────────────────┐
│            小程序前端展示层               │
├─────────────────────────────────────────┤
│              游戏逻辑层                   │
│   ├── 迷宫生成与寻路                     │
│   └── 消消乐匹配与动画                   │
├─────────────────────────────────────────┤
│              渲染引擎层                   │
│   ├── Canvas 2D 渲染                     │
│   └── 动画系统                           │
├─────────────────────────────────────────┤
│              数据管理层                   │
│   ├── 本地存储                           │
│   └── 状态管理                           │
└─────────────────────────────────────────┘
```

### 1.2 技术选型
- **开发框架**：微信小程序原生框架
- **渲染技术**：Canvas 2D API
- **动画方案**：requestAnimationFrame + 缓动函数
- **状态管理**：单例模式 + 事件驱动
- **数据存储**：wx.setStorageSync / wx.getStorageSync

## 2. 核心算法实现

### 2.1 迷宫生成算法（递归回溯）

```javascript
class MazeGenerator {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.maze = [];
    this.initMaze();
  }

  initMaze() {
    // 初始化迷宫，全部设为墙（1）
    for (let y = 0; y < this.height; y++) {
      this.maze[y] = [];
      for (let x = 0; x < this.width; x++) {
        this.maze[y][x] = 1;
      }
    }
  }

  generate() {
    // 从(1,1)开始生成迷宫
    this.carvePath(1, 1);
    
    // 设置起点和终点
    this.maze[1][1] = 2; // 起点
    this.maze[this.height-2][this.width-2] = 3; // 终点
    
    // 创建额外路径，避免迷宫过于简单
    this.createLoops();
    
    return this.maze;
  }

  carvePath(x, y) {
    // 标记当前位置为路径
    this.maze[y][x] = 0;
    
    // 随机打乱四个方向
    const directions = [
      [0, -2], // 上
      [2, 0],  // 右
      [0, 2],  // 下
      [-2, 0]  // 左
    ];
    this.shuffle(directions);
    
    // 尝试每个方向
    for (let [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      
      // 检查边界和是否已访问
      if (nx > 0 && nx < this.width - 1 && 
          ny > 0 && ny < this.height - 1 && 
          this.maze[ny][nx] === 1) {
        
        // 打通墙壁
        this.maze[y + dy/2][x + dx/2] = 0;
        
        // 递归继续生成
        this.carvePath(nx, ny);
      }
    }
  }

  createLoops() {
    // 随机打通一些墙壁，创建多条路径
    const loopCount = Math.floor(this.width * this.height / 50);
    
    for (let i = 0; i < loopCount; i++) {
      const x = Math.floor(Math.random() * (this.width - 2)) + 1;
      const y = Math.floor(Math.random() * (this.height - 2)) + 1;
      
      if (this.maze[y][x] === 1) {
        // 检查是否可以安全打通
        if (this.canBreakWall(x, y)) {
          this.maze[y][x] = 0;
        }
      }
    }
  }

  canBreakWall(x, y) {
    // 检查打通墙壁是否会破坏迷宫结构
    let pathCount = 0;
    const neighbors = [[0,-1], [1,0], [0,1], [-1,0]];
    
    for (let [dx, dy] of neighbors) {
      if (this.maze[y+dy] && this.maze[y+dy][x+dx] === 0) {
        pathCount++;
      }
    }
    
    return pathCount === 2; // 恰好连接两条路径
  }

  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}
```

### 2.2 消消乐匹配算法

```javascript
class Match3Logic {
  constructor(gridSize = 8) {
    this.gridSize = gridSize;
    this.grid = [];
    this.colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
  }

  // 查找所有匹配
  findMatches() {
    const matches = new Set();
    
    // 检查横向匹配
    this.findHorizontalMatches(matches);
    
    // 检查纵向匹配
    this.findVerticalMatches(matches);
    
    // 检查连通区域
    this.findConnectedMatches(matches);
    
    return Array.from(matches);
  }

  findHorizontalMatches(matches) {
    for (let row = 0; row < this.gridSize; row++) {
      for (let col = 0; col < this.gridSize - 2; col++) {
        const color = this.grid[row][col];
        if (!color) continue;
        
        // 检查连续相同颜色
        let matchLength = 1;
        while (col + matchLength < this.gridSize && 
               this.grid[row][col + matchLength] === color) {
          matchLength++;
        }
        
        // 如果3个或以上，添加到匹配集合
        if (matchLength >= 3) {
          for (let i = 0; i < matchLength; i++) {
            matches.add(`${row},${col + i}`);
          }
        }
      }
    }
  }

  findVerticalMatches(matches) {
    for (let col = 0; col < this.gridSize; col++) {
      for (let row = 0; row < this.gridSize - 2; row++) {
        const color = this.grid[row][col];
        if (!color) continue;
        
        let matchLength = 1;
        while (row + matchLength < this.gridSize && 
               this.grid[row + matchLength][col] === color) {
          matchLength++;
        }
        
        if (matchLength >= 3) {
          for (let i = 0; i < matchLength; i++) {
            matches.add(`${row + i},${col}`);
          }
        }
      }
    }
  }

  findConnectedMatches(matches) {
    const visited = new Set();
    
    for (let row = 0; row < this.gridSize; row++) {
      for (let col = 0; col < this.gridSize; col++) {
        const key = `${row},${col}`;
        if (visited.has(key) || !this.grid[row][col]) continue;
        
        // DFS查找连通区域
        const connected = this.dfsConnected(row, col, visited);
        
        // 如果连通区域>=3，添加到匹配
        if (connected.length >= 3) {
          connected.forEach(pos => matches.add(pos));
        }
      }
    }
  }

  dfsConnected(row, col, visited) {
    const color = this.grid[row][col];
    const stack = [[row, col]];
    const connected = [];
    
    while (stack.length > 0) {
      const [r, c] = stack.pop();
      const key = `${r},${c}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      connected.push(key);
      
      // 检查四个方向
      const neighbors = [
        [r-1, c], [r+1, c], [r, c-1], [r, c+1]
      ];
      
      for (let [nr, nc] of neighbors) {
        if (nr >= 0 && nr < this.gridSize && 
            nc >= 0 && nc < this.gridSize &&
            this.grid[nr][nc] === color &&
            !visited.has(`${nr},${nc}`)) {
          stack.push([nr, nc]);
        }
      }
    }
    
    return connected;
  }

  // 消除方块后的下落逻辑
  dropBlocks() {
    let moved = false;
    
    for (let col = 0; col < this.gridSize; col++) {
      let writePos = this.gridSize - 1;
      
      // 从下往上扫描
      for (let row = this.gridSize - 1; row >= 0; row--) {
        if (this.grid[row][col]) {
          if (row !== writePos) {
            this.grid[writePos][col] = this.grid[row][col];
            this.grid[row][col] = null;
            moved = true;
          }
          writePos--;
        }
      }
    }
    
    return moved;
  }

  // 填充空缺
  fillEmpty() {
    let filled = false;
    
    for (let row = 0; row < this.gridSize; row++) {
      for (let col = 0; col < this.gridSize; col++) {
        if (!this.grid[row][col]) {
          this.grid[row][col] = this.getRandomColor();
          filled = true;
        }
      }
    }
    
    return filled;
  }

  getRandomColor() {
    return this.colors[Math.floor(Math.random() * this.colors.length)];
  }
}
```

## 3. Canvas 渲染优化

### 3.1 双缓冲技术
```javascript
class CanvasRenderer {
  constructor(canvasId, width, height) {
    // 主画布（显示用）
    this.canvas = wx.createCanvasContext(canvasId);
    
    // 离屏画布（缓冲用）
    this.offscreenCanvas = wx.createOffscreenCanvas({
      type: '2d',
      width: width,
      height: height
    });
    this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    
    this.width = width;
    this.height = height;
  }

  // 在离屏画布上绘制
  drawOffscreen(drawFunc) {
    drawFunc(this.offscreenCtx);
  }

  // 将离屏画布内容复制到主画布
  present() {
    this.canvas.drawImage(
      this.offscreenCanvas,
      0, 0, this.width, this.height,
      0, 0, this.width, this.height
    );
    this.canvas.draw();
  }

  // 清空画布
  clear() {
    this.offscreenCtx.clearRect(0, 0, this.width, this.height);
  }
}
```

### 3.2 脏矩形渲染
```javascript
class DirtyRectManager {
  constructor() {
    this.dirtyRects = [];
  }

  // 标记需要重绘的区域
  markDirty(x, y, width, height) {
    this.dirtyRects.push({ x, y, width, height });
  }

  // 合并重叠的脏矩形
  mergeDirtyRects() {
    if (this.dirtyRects.length === 0) return [];
    
    // 简单实现：合并所有矩形为一个大矩形
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    
    for (let rect of this.dirtyRects) {
      minX = Math.min(minX, rect.x);
      minY = Math.min(minY, rect.y);
      maxX = Math.max(maxX, rect.x + rect.width);
      maxY = Math.max(maxY, rect.y + rect.height);
    }
    
    return [{
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    }];
  }

  // 清空脏矩形列表
  clear() {
    this.dirtyRects = [];
  }

  // 检查是否需要重绘
  isDirty() {
    return this.dirtyRects.length > 0;
  }
}
```

## 4. 动画系统

### 4.1 缓动函数
```javascript
const Easing = {
  // 线性
  linear: (t) => t,
  
  // 二次缓动
  quadIn: (t) => t * t,
  quadOut: (t) => t * (2 - t),
  quadInOut: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  
  // 三次缓动
  cubicIn: (t) => t * t * t,
  cubicOut: (t) => (--t) * t * t + 1,
  cubicInOut: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  
  // 弹性缓动
  elasticOut: (t) => {
    const p = 0.3;
    return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
  },
  
  // 回弹缓动
  backOut: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
};
```

### 4.2 动画管理器
```javascript
class AnimationManager {
  constructor() {
    this.animations = [];
    this.running = false;
  }

  // 添加动画
  add(animation) {
    this.animations.push(animation);
    if (!this.running) {
      this.start();
    }
  }

  // 创建补间动画
  tween(target, props, duration, easing = 'linear') {
    const animation = {
      target,
      startProps: {},
      endProps: props,
      duration,
      elapsed: 0,
      easing: Easing[easing] || Easing.linear,
      onComplete: null
    };
    
    // 记录起始值
    for (let key in props) {
      animation.startProps[key] = target[key];
    }
    
    this.add(animation);
    
    // 返回Promise用于链式调用
    return new Promise(resolve => {
      animation.onComplete = resolve;
    });
  }

  // 更新动画
  update(deltaTime) {
    const completed = [];
    
    for (let i = 0; i < this.animations.length; i++) {
      const anim = this.animations[i];
      anim.elapsed += deltaTime;
      
      const progress = Math.min(anim.elapsed / anim.duration, 1);
      const easedProgress = anim.easing(progress);
      
      // 更新属性
      for (let key in anim.endProps) {
        const start = anim.startProps[key];
        const end = anim.endProps[key];
        anim.target[key] = start + (end - start) * easedProgress;
      }
      
      // 检查是否完成
      if (progress >= 1) {
        completed.push(i);
        if (anim.onComplete) {
          anim.onComplete();
        }
      }
    }
    
    // 移除完成的动画
    for (let i = completed.length - 1; i >= 0; i--) {
      this.animations.splice(completed[i], 1);
    }
    
    // 如果没有动画了，停止更新
    if (this.animations.length === 0) {
      this.stop();
    }
  }

  // 开始动画循环
  start() {
    if (this.running) return;
    
    this.running = true;
    this.lastTime = Date.now();
    
    const animate = () => {
      if (!this.running) return;
      
      const now = Date.now();
      const deltaTime = (now - this.lastTime) / 1000;
      this.lastTime = now;
      
      this.update(deltaTime);
      
      wx.nextTick(animate);
    };
    
    animate();
  }

  // 停止动画循环
  stop() {
    this.running = false;
  }

  // 清空所有动画
  clear() {
    this.animations = [];
    this.stop();
  }
}
```

## 5. 粒子系统

### 5.1 粒子类
```javascript
class Particle {
  constructor(x, y, options = {}) {
    this.x = x;
    this.y = y;
    this.vx = options.vx || (Math.random() - 0.5) * 200;
    this.vy = options.vy || (Math.random() - 0.5) * 200;
    this.color = options.color || '#FFD700';
    this.size = options.size || Math.random() * 5 + 2;
    this.life = options.life || 1.0;
    this.decay = options.decay || 0.02;
    this.gravity = options.gravity || 200;
  }

  update(deltaTime) {
    // 更新位置
    this.x += this.vx * deltaTime;
    this.y += this.vy * deltaTime;
    
    // 应用重力
    this.vy += this.gravity * deltaTime;
    
    // 应用阻力
    this.vx *= 0.98;
    this.vy *= 0.98;
    
    // 减少生命值
    this.life -= this.decay;
    
    // 更新大小
    this.size *= 0.98;
    
    return this.life > 0;
  }

  draw(ctx) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, this.life);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}
```

### 5.2 粒子发射器
```javascript
class ParticleEmitter {
  constructor(x, y, options = {}) {
    this.x = x;
    this.y = y;
    this.particles = [];
    this.emissionRate = options.emissionRate || 10;
    this.maxParticles = options.maxParticles || 100;
    this.particleOptions = options.particleOptions || {};
    this.emitting = false;
    this.burstMode = options.burstMode || false;
  }

  // 发射粒子
  emit(count = 1) {
    for (let i = 0; i < count; i++) {
      if (this.particles.length >= this.maxParticles) break;
      
      const particle = new Particle(
        this.x + (Math.random() - 0.5) * 10,
        this.y + (Math.random() - 0.5) * 10,
        this.particleOptions
      );
      
      this.particles.push(particle);
    }
  }

  // 爆发模式
  burst(count = 20) {
    this.emit(count);
  }

  // 更新粒子
  update(deltaTime) {
    // 持续发射
    if (this.emitting && !this.burstMode) {
      this.emit(Math.floor(this.emissionRate * deltaTime));
    }
    
    // 更新所有粒子
    this.particles = this.particles.filter(particle => 
      particle.update(deltaTime)
    );
  }

  // 绘制粒子
  draw(ctx) {
    this.particles.forEach(particle => {
      particle.draw(ctx);
    });
  }

  // 开始发射
  start() {
    this.emitting = true;
  }

  // 停止发射
  stop() {
    this.emitting = false;
  }

  // 清空粒子
  clear() {
    this.particles = [];
  }
}
```

## 6. 音效系统

### 6.1 音效管理器
```javascript
class SoundManager {
  constructor() {
    this.enabled = true;
    this.audioContext = wx.createInnerAudioContext();
    this.sounds = new Map();
    this.preloadSounds();
  }

  // 预加载音效
  preloadSounds() {
    const soundList = [
      { key: 'click', url: '/assets/sounds/click.mp3' },
      { key: 'move', url: '/assets/sounds/move.mp3' },
      { key: 'match', url: '/assets/sounds/match.mp3' },
      { key: 'victory', url: '/assets/sounds/victory.mp3' },
      { key: 'explosion', url: '/assets/sounds/explosion.mp3' }
    ];
    
    soundList.forEach(({ key, url }) => {
      const audio = wx.createInnerAudioContext();
      audio.src = url;
      audio.volume = 0.5;
      this.sounds.set(key, audio);
    });
  }

  // 播放音效
  play(soundKey, options = {}) {
    if (!this.enabled) return;
    
    const audio = this.sounds.get(soundKey);
    if (!audio) {
      console.warn(`Sound '${soundKey}' not found`);
      return;
    }
    
    // 设置音量
    if (options.volume !== undefined) {
      audio.volume = options.volume;
    }
    
    // 从头播放
    audio.seek(0);
    audio.play();
  }

  // 播放背景音乐
  playBGM(url, loop = true) {
    if (!this.bgm) {
      this.bgm = wx.createInnerAudioContext();
      this.bgm.loop = loop;
      this.bgm.volume = 0.3;
    }
    
    this.bgm.src = url;
    this.bgm.play();
  }

  // 停止背景音乐
  stopBGM() {
    if (this.bgm) {
      this.bgm.stop();
    }
  }

  // 切换音效开关
  toggle() {
    this.enabled = !this.enabled;
    if (!this.enabled && this.bgm) {
      this.bgm.pause();
    } else if (this.enabled && this.bgm) {
      this.bgm.play();
    }
  }

  // 震动反馈
  vibrate(type = 'light') {
    if (this.enabled) {
      wx.vibrateShort({ type });
    }
  }
}

// 单例模式
const soundManager = new SoundManager();
export default soundManager;
```

## 7. 数据管理

### 7.1 游戏数据管理
```javascript
class GameDataManager {
  constructor() {
    this.storageKey = 'smallDreamGame';
    this.data = this.loadData();
  }

  // 加载数据
  loadData() {
    try {
      const data = wx.getStorageSync(this.storageKey);
      return data || this.getDefaultData();
    } catch (e) {
      console.error('Load data failed:', e);
      return this.getDefaultData();
    }
  }

  // 获取默认数据
  getDefaultData() {
    return {
      settings: {
        soundEnabled: true,
        musicEnabled: true,
        vibrationEnabled: true
      },
      maze: {
        bestTime: {},
        bestSteps: {},
        completed: []
      },
      match3: {
        highScore: 0,
        totalScore: 0,
        gamesPlayed: 0,
        maxCombo: 0
      },
      achievements: [],
      statistics: {
        totalPlayTime: 0,
        lastPlayDate: null
      }
    };
  }

  // 保存数据
  saveData() {
    try {
      wx.setStorageSync(this.storageKey, this.data);
      return true;
    } catch (e) {
      console.error('Save data failed:', e);
      return false;
    }
  }

  // 更新迷宫记录
  updateMazeRecord(difficulty, time, steps) {
    const maze = this.data.maze;
    
    // 更新最佳时间
    if (!maze.bestTime[difficulty] || time < maze.bestTime[difficulty]) {
      maze.bestTime[difficulty] = time;
    }
    
    // 更新最少步数
    if (!maze.bestSteps[difficulty] || steps < maze.bestSteps[difficulty]) {
      maze.bestSteps[difficulty] = steps;
    }
    
    // 添加到完成列表
    maze.completed.push({
      difficulty,
      time,
      steps,
      date: new Date().toISOString()
    });
    
    this.saveData();
  }

  // 更新消消乐记录
  updateMatch3Record(score, combo) {
    const match3 = this.data.match3;
    
    // 更新最高分
    if (score > match3.highScore) {
      match3.highScore = score;
    }
    
    // 更新总分
    match3.totalScore += score;
    
    // 更新游戏次数
    match3.gamesPlayed++;
    
    // 更新最大连击
    if (combo > match3.maxCombo) {
      match3.maxCombo = combo;
    }
    
    this.saveData();
  }

  // 获取设置
  getSettings() {
    return this.data.settings;
  }

  // 更新设置
  updateSettings(settings) {
    Object.assign(this.data.settings, settings);
    this.saveData();
  }

  // 解锁成就
  unlockAchievement(achievementId) {
    if (!this.data.achievements.includes(achievementId)) {
      this.data.achievements.push(achievementId);
      this.saveData();
      return true;
    }
    return false;
  }

  // 清空数据
  clearData() {
    this.data = this.getDefaultData();
    this.saveData();
  }
}

// 导出单例
const gameDataManager = new GameDataManager();
export default gameDataManager;
```

## 8. 性能监控

### 8.1 FPS监控器
```javascript
class FPSMonitor {
  constructor() {
    this.fps = 0;
    this.frames = 0;
    this.lastTime = Date.now();
    this.updateInterval = 1000; // 每秒更新一次
  }

  // 每帧调用
  tick() {
    this.frames++;
    
    const now = Date.now();
    const elapsed = now - this.lastTime;
    
    if (elapsed >= this.updateInterval) {
      this.fps = Math.round((this.frames * 1000) / elapsed);
      this.frames = 0;
      this.lastTime = now;
      
      // 性能警告
      if (this.fps < 30) {
        console.warn(`Low FPS detected: ${this.fps}`);
      }
    }
  }

  // 获取当前FPS
  getFPS() {
    return this.fps;
  }

  // 绘制FPS
  draw(ctx, x = 10, y = 20) {
    ctx.save();
    ctx.fillStyle = this.fps < 30 ? 'red' : 'green';
    ctx.font = '14px Arial';
    ctx.fillText(`FPS: ${this.fps}`, x, y);
    ctx.restore();
  }
}
```

### 8.2 内存监控
```javascript
class MemoryMonitor {
  constructor() {
    this.checkInterval = 5000; // 5秒检查一次
    this.lastCheck = Date.now();
    this.memoryUsage = 0;
  }

  check() {
    const now = Date.now();
    if (now - this.lastCheck < this.checkInterval) return;
    
    this.lastCheck = now;
    
    // 微信小程序内存监控
    if (wx.onMemoryWarning) {
      wx.onMemoryWarning((res) => {
        console.warn('Memory warning:', res.level);
        this.handleMemoryWarning(res.level);
      });
    }
  }

  handleMemoryWarning(level) {
    // 根据警告级别采取措施
    switch(level) {
      case 5:
        // 内存不足5%
        console.log('Clearing particle effects...');
        this.clearParticles();
        break;
      case 10:
        // 内存不足10%
        console.log('Reducing animation quality...');
        this.reduceAnimations();
        break;
      case 15:
        // 内存不足15%
        console.log('Normal memory usage');
        break;
    }
  }

  clearParticles() {
    // 清理粒子效果
    if (window.particleEmitters) {
      window.particleEmitters.forEach(emitter => emitter.clear());
    }
  }

  reduceAnimations() {
    // 降低动画质量
    if (window.animationManager) {
      window.animationManager.clear();
    }
  }
}
```

## 9. 错误处理

### 9.1 全局错误处理
```javascript
class ErrorHandler {
  constructor() {
    this.errors = [];
    this.maxErrors = 50;
    this.setupHandlers();
  }

  setupHandlers() {
    // 捕获未处理的Promise错误
    wx.onUnhandledRejection((res) => {
      this.logError('UnhandledRejection', res.reason);
    });
    
    // 捕获页面错误
    wx.onError((error) => {
      this.logError('PageError', error);
    });
  }

  logError(type, error) {
    const errorInfo = {
      type,
      message: error.message || error,
      stack: error.stack,
      time: new Date().toISOString(),
      page: getCurrentPages()[0]?.route
    };
    
    this.errors.push(errorInfo);
    
    // 限制错误日志数量
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    // 开发环境输出错误
    if (__DEV__) {
      console.error(type, error);
    }
    
    // 上报错误（生产环境）
    if (!__DEV__) {
      this.reportError(errorInfo);
    }
  }

  reportError(errorInfo) {
    // 发送错误到服务器
    wx.request({
      url: 'https://api.example.com/error-report',
      method: 'POST',
      data: errorInfo,
      fail: () => {
        // 错误上报失败，存储到本地
        this.saveErrorLocal(errorInfo);
      }
    });
  }

  saveErrorLocal(errorInfo) {
    try {
      const errors = wx.getStorageSync('errorLogs') || [];
      errors.push(errorInfo);
      wx.setStorageSync('errorLogs', errors.slice(-20));
    } catch (e) {
      // 存储失败，忽略
    }
  }

  getErrors() {
    return this.errors;
  }

  clearErrors() {
    this.errors = [];
  }
}

// 创建全局错误处理实例
const errorHandler = new ErrorHandler();
export default errorHandler;
```

## 10. 调试工具

### 10.1 游戏调试面板
```javascript
class DebugPanel {
  constructor() {
    this.visible = false;
    this.stats = {
      fps: 0,
      drawCalls: 0,
      particles: 0,
      animations: 0
    };
  }

  toggle() {
    this.visible = !this.visible;
  }

  update(stats) {
    Object.assign(this.stats, stats);
  }

  draw(ctx) {
    if (!this.visible) return;
    
    const x = 10;
    let y = 30;
    const lineHeight = 20;
    
    ctx.save();
    
    // 背景
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(x - 5, y - 20, 150, 100);
    
    // 文字
    ctx.fillStyle = '#00FF00';
    ctx.font = '12px monospace';
    
    ctx.fillText(`FPS: ${this.stats.fps}`, x, y);
    y += lineHeight;
    
    ctx.fillText(`Draw Calls: ${this.stats.drawCalls}`, x, y);
    y += lineHeight;
    
    ctx.fillText(`Particles: ${this.stats.particles}`, x, y);
    y += lineHeight;
    
    ctx.fillText(`Animations: ${this.stats.animations}`, x, y);
    
    ctx.restore();
  }
}
```

---

*文档版本：V1.0*  
*更新日期：2024年*  
*技术负责人：开发团队*